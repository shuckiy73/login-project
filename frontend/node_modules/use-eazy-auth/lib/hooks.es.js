import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import React, { useRef, useReducer, useEffect, useCallback, useMemo, createContext, useContext, useState } from 'react';
import { from, throwError, Subject, of, concat, defer, EMPTY } from 'rxjs';
import _typeof from '@babel/runtime/helpers/esm/typeof';
import { mergeMap, map, catchError, tap, exhaustMap, filter, takeUntil, publish, take } from 'rxjs/operators';
import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';

var noopStorageBackend = {
  getItem: function getItem() {
    return null;
  },
  setItem: function setItem() {},
  removeItem: function removeItem() {}
}; // If a promise return them if other return the value as resolved promise ...

function getResolvedOrPromise(value) {
  // Check if a Promise...
  if (value !== null && _typeof(value) === 'object' && typeof value.then === 'function') {
    return value;
  }

  return Promise.resolve(value);
}

var checkStorage = function checkStorage(storageCandidate) {
  if (typeof storageCandidate.getItem !== 'function') {
    console.error('[use-eazy-auth] Invalid storage backend, it lacks function getItem, no storage will be used');
    return false;
  }

  if (typeof storageCandidate.setItem !== 'function') {
    console.error('[use-eazy-auth] Invalid storage backend, it lacks function setItem, no storage will be used');
    return false;
  }

  if (typeof storageCandidate.removeItem !== 'function') {
    console.error('[use-eazy-auth] Invalid storage backend, it lacks function removeItem, no storage will be used');
    return false;
  }

  return true;
};

/**
 * makeStorage creates a wrapper around a compatible StorageLike object
 * The wrapper solves two tasks
 * - serialize and deserialize the token bag to string
 * - return a consistent Promise-base interface towards the store
 *     in particular, some stores like ReactNative AsyncStorage are asynchronous,
 *     while window.localStorage is synchronous, we want to uniform these behaviours
 * @param {StorageBackend} givenStorageBackend
 * @param {string} storageNamespace
 */
function makeStorage(givenStorageBackend, storageNamespace) {
  var storageBackend = noopStorageBackend;

  if (typeof givenStorageBackend === 'undefined' || givenStorageBackend === null) {
    if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {
      // If provided by environment use local storage
      storageBackend = window.localStorage;
    }
  } else if (givenStorageBackend !== false && checkStorage(givenStorageBackend)) {
    // When given use provided storage backend
    storageBackend = givenStorageBackend;
  }

  var getTokens = function getTokens() {
    return getResolvedOrPromise(storageBackend.getItem(storageNamespace)).then(function (rawTokens) {
      // Empty storage...
      if (typeof rawTokens !== 'string') {
        return Promise.reject();
      }

      try {
        var parsedTokens = JSON.parse(rawTokens);

        if (_typeof(parsedTokens) === 'object' && parsedTokens !== null && parsedTokens.accessToken) {
          // TODO: Maybe validate in more proper way the content of local storeage....
          return Promise.resolve(parsedTokens);
        }

        return Promise.reject();
      } catch (e) {
        // BAD JSON
        return Promise.reject();
      }
    });
  };

  var setTokens = function setTokens(tokens) {
    return getResolvedOrPromise(storageBackend.setItem(storageNamespace, JSON.stringify(tokens)));
  };

  var removeTokens = function removeTokens() {
    return getResolvedOrPromise(storageBackend.removeItem(storageNamespace));
  };

  return {
    setTokens: setTokens,
    removeTokens: removeTokens,
    getTokens: getTokens
  };
}

// Thanks 2 ma man @Andarist <3
function useConstant(fn) {
  var ref = useRef();

  if (!ref.current) {
    ref.current = {
      v: fn()
    };
  }

  return ref.current.v;
}

var BOOTSTRAP_AUTH_START = 'BOOTSTRAP_AUTH_START';
var BOOTSTRAP_AUTH_END = 'BOOTSTRAP_AUTH_END';
var LOGIN_LOADING = 'LOGIN_LOADING';
var LOGIN_FAILURE = 'LOGIN_FAILURE';
var LOGIN_SUCCESS = 'LOGIN_SUCCESS';
var CLEAR_LOGIN_ERROR = 'CLEAR_LOGIN_ERROR';
var LOGOUT = 'LOGOUT';
var TOKEN_REFRESHING = 'TOKEN_REFRESHING';
var TOKEN_REFRESHED = 'TOKEN_REFRESHED';
var UPDATE_USER = 'UPDATE_USER';
var PATCH_USER = 'PATCH_USER';
var SET_TOKENS = 'SET_TOKENS';

function makeCallWithRefresh(accessToken, refreshToken, refreshTokenCall) {
  return function (apiFn) {
    return from(apiFn(accessToken)).pipe(map(function (response) {
      return {
        response: response,
        refreshedTokens: null
      };
    }), catchError(function (error) {
      if ( // Try refresh when:
      // Got an auth error
      error.status === 401 && // We have a refresh token and an api call that we can perform
      // 2 refresh it!
      refreshToken && typeof refreshTokenCall === 'function') {
        return from(refreshTokenCall(refreshToken)).pipe(mergeMap(function (refreshedTokens) {
          // Yeah refresh appends!
          // Ok now retry the apiFn \w refreshed shit!
          return from(apiFn(refreshedTokens.accessToken)).pipe(map(function (response) {
            // Curry the refreshed shit \w response
            return {
              response: response,
              refreshedTokens: refreshedTokens
            };
          }), // The error of new api fn don't really means
          // instead reject the original 401 to enforce logout process
          catchError(function () {
            return throwError(error);
          }));
        }), // At this point the refresh error does not is so usefuel
        // instead reject the original 401 to enforce logout process
        catchError(function () {
          return throwError(error);
        }));
      } // Normal rejection


      return throwError(error);
    }));
  };
}

function getBootAuthObservable(meCall, refreshTokenCall, storage) {
  return from(storage.getTokens()).pipe(mergeMap(function (tokensInStorage) {
    // Prepare the ~ M A G I K ~ Api call with refresh
    var callWithRefresh = makeCallWithRefresh(tokensInStorage.accessToken, tokensInStorage.refreshToken, refreshTokenCall);
    return callWithRefresh(meCall).pipe(catchError(function (err) {
      // Clear bad tokens from storage
      storage.removeTokens();
      return throwError(err);
    }), map(function (responseWithRefresh) {
      return {
        tokensInStorage: tokensInStorage,
        responseWithRefresh: responseWithRefresh
      };
    }));
  }));
} // Boot eazy-auth
// Read tokens from provided storage
// if any try to use theese to authenticate the user \w the given meCall
// LS -> meCall(token) -> user
// dispatch to top state and keep token in sync using a React useRef

function bootAuth(meCall, refreshTokenCall, storage, dispatch, tokenRef, bootRef) {
  // My Auth Alredy Booted
  if (bootRef.current) {
    return function () {};
  } // Shortcut to finish boot process default not authenticated


  function endBoot() {
    var payload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      authenticated: false
    };
    bootRef.current = true;
    dispatch({
      type: BOOTSTRAP_AUTH_END,
      payload: payload
    });
  }

  dispatch({
    type: BOOTSTRAP_AUTH_START
  });
  var subscription = getBootAuthObservable(meCall, refreshTokenCall, storage).subscribe(function (_ref) {
    var tokensInStorage = _ref.tokensInStorage,
        responseWithRefresh = _ref.responseWithRefresh;
    var user = responseWithRefresh.response,
        refreshedTokens = responseWithRefresh.refreshedTokens; // If token refreshed take the token refreshed as valid otherwise use the good
    // old tokens from local storage

    var validTokens = refreshedTokens ? refreshedTokens : tokensInStorage; // GANG saved the valid tokens to the current ref!

    tokenRef.current = validTokens; // Tell to ma reducer

    endBoot(_objectSpread({
      authenticated: true,
      user: user
    }, validTokens)); // Plus only if refreshed save freshed in local storage!

    if (refreshedTokens) {
      storage.setTokens(refreshedTokens);
    }
  }, endBoot);
  return function () {
    return subscription.unsubscribe();
  };
}
function makePerformLogin(loginCall, meCall, storage, dispatch, tokenRef) {
  var loginTrigger = new Subject();
  var subscription = loginTrigger.asObservable().pipe(tap(function () {
    return dispatch({
      type: LOGIN_LOADING
    });
  }), exhaustMap(function (loginCredentials) {
    return from(loginCall(loginCredentials)).pipe(mergeMap(function (loginResponse) {
      var accessToken = loginResponse.accessToken;
      return from(meCall(accessToken, loginResponse)).pipe(map(function (user) {
        return {
          type: LOGIN_SUCCESS,
          payload: {
            loginResponse: loginResponse,
            user: user
          }
        };
      }));
    }), catchError(function (error) {
      return of({
        type: LOGIN_FAILURE,
        error: error
      });
    }));
  })).subscribe(function (action) {
    if (action.type === LOGIN_SUCCESS) {
      // Login Flow Success
      var _action$payload = action.payload,
          loginResponse = _action$payload.loginResponse,
          user = _action$payload.user;
      var accessToken = loginResponse.accessToken,
          refreshToken = loginResponse.refreshToken,
          _loginResponse$expire = loginResponse.expires,
          expires = _loginResponse$expire === void 0 ? null : _loginResponse$expire; // Save the token ref GANG!

      tokenRef.current = {
        accessToken: accessToken,
        refreshToken: refreshToken,
        expires: expires
      };
      dispatch({
        type: LOGIN_SUCCESS,
        payload: {
          user: user,
          expires: expires,
          accessToken: accessToken,
          refreshToken: refreshToken
        }
      }); // Ok this can be an async action sure but
      // is better wait them and so do waiting the use before
      // notify them that login was success i don't kown....

      storage.setTokens({
        expires: expires,
        accessToken: accessToken,
        refreshToken: refreshToken
      });
    } else if (action.type === LOGIN_FAILURE) {
      // Login Flow Failure
      dispatch(action);
    }
  });

  var performLogin = function performLogin(loginCredentials) {
    loginTrigger.next(loginCredentials);
  };

  var unsubscribe = function unsubscribe() {
    subscription.unsubscribe();
  };

  return [performLogin, unsubscribe];
}

// Emulate a 401 Unauthorized from server ....
var UNAUTHORIZED_ERROR_SHAPE = {
  status: 401,
  fromRefresh: true
};

var tokenRefreshed = function tokenRefreshed(refreshedTokens) {
  return {
    type: TOKEN_REFRESHED,
    payload: refreshedTokens
  };
};

var tokenRefreshing = function tokenRefreshing() {
  return {
    type: TOKEN_REFRESHING
  };
}; // Wecolme 2 ~ H E L L ~
// callApi implemented using rxjs too keep only 1 refreshing task at time


function makeCallApiRx(refreshTokenCall, dispatch, storage, tokenRef, bootRef, actionObservable) {
  var logout = function logout() {
    return dispatch({
      type: LOGOUT
    });
  };

  var refreshingSemaphore = false; // An Observable that emit when logout was dispatched

  var logoutObservable = actionObservable.pipe(filter(function (action) {
    return action.type === LOGOUT;
  })); // Subject for emit refresh tasks

  var refreshEmitter = new Subject(); // An Observable that perform the refresh token call
  // until logout was dispatched and emit actions

  var refreshRoutine = refreshEmitter.asObservable().pipe(exhaustMap(function (refreshToken) {
    return concat(of(tokenRefreshing()), from(refreshTokenCall && refreshToken ? refreshTokenCall(refreshToken) : throwError(null)).pipe(map(function (refreshResponse) {
      return tokenRefreshed({
        accessToken: refreshResponse.accessToken,
        refreshToken: refreshResponse.refreshToken,
        expires: refreshResponse.expires
      });
    }), catchError(function () {
      return of({
        type: LOGOUT
      });
    }), takeUntil(logoutObservable)));
  }), publish()); // Make an Observable that complete with access token
  // when TOKEN_REFRESHED action is dispatched
  // or throw a simil 401 error when logout is dispatched
  // this can be used as 'virtual' refreshToken() api

  function waitForStoreRefreshObservable() {
    return actionObservable.pipe(filter(function (action) {
      return action.type === TOKEN_REFRESHED || action.type === LOGOUT;
    }), take(1), mergeMap(function (action) {
      if (action.type === LOGOUT) {
        return throwError(UNAUTHORIZED_ERROR_SHAPE);
      }

      return of(action.payload.accessToken);
    }));
  } // Make an Observable that complete with token or throw a 401 like error
  // Handle theee situations:
  // - Wait eazy auth to booted before try to getting an access token
  // - Wait a peening refresh task (if any) before getting an access token


  function getAccessToken() {
    var authBooted = bootRef.current; // Wait eazy-auth boot ...

    var waitBootObservable;

    if (!authBooted) {
      waitBootObservable = actionObservable.pipe(filter(function (action) {
        return action.type === BOOTSTRAP_AUTH_END;
      }), take(1), mergeMap(function () {
        return EMPTY;
      }));
    } else {
      waitBootObservable = EMPTY;
    }

    return concat(waitBootObservable, defer(function () {
      // Get the actual token
      var _ref = tokenRef.current || {},
          _ref$accessToken = _ref.accessToken,
          accessToken = _ref$accessToken === void 0 ? null : _ref$accessToken; // Not authenticated, complete empty


      if (accessToken === null) {
        return of(null);
      }

      var refreshing = refreshingSemaphore; // Refresh in place wait from store

      if (refreshing) {
        return waitForStoreRefreshObservable();
      } // Valid acces token in store!


      return of(accessToken);
    }));
  } // Make an observable that refresh token
  // only with no pending refresh is in place
  // complete \w refresh token or throw a 401 like error


  function refreshOnUnauth(accessToken2Refresh) {
    var _ref2 = tokenRef.current || {},
        _ref2$accessToken = _ref2.accessToken,
        accessToken = _ref2$accessToken === void 0 ? null : _ref2$accessToken,
        _ref2$refreshToken = _ref2.refreshToken,
        refreshToken = _ref2$refreshToken === void 0 ? null : _ref2$refreshToken;

    if (accessToken === null) {
      // An error occurred but in the meanwhile
      // logout or bad refresh was happends...
      return throwError(UNAUTHORIZED_ERROR_SHAPE);
    }

    var refreshing = refreshingSemaphore;

    if (refreshing) {
      return waitForStoreRefreshObservable();
    }

    if (accessToken !== accessToken2Refresh) {
      // Another cool guy has refresh ma token
      // return new tokens ...
      return of(accessToken);
    } // Ok this point token match the current
    // no refresh ar in place so ....
    // start refresh!


    refreshEmitter.next(refreshToken);
    return waitForStoreRefreshObservable();
  } // Logout user when an unauthorized error happens or refresh failed


  function unauthLogout(badAccessToken, error) {
    var _ref3 = tokenRef.current || {},
        _ref3$accessToken = _ref3.accessToken,
        accessToken = _ref3$accessToken === void 0 ? null : _ref3$accessToken;

    if (accessToken !== null && !refreshingSemaphore && accessToken === badAccessToken) {
      if (_typeof(error) === 'object' && error.status === 401) {
        logout();
      }
      /*else if (typeof error === 'object' && error.status === 403) {
      logout({ fromPermission: true })
      }*/

    }
  }

  function onObsevableError(error, apiFn, firstAccessToken, args) {
    if (firstAccessToken !== null) {
      if (typeof refreshTokenCall !== 'function') {
        // Refresh can't be called
        // notify logout when needed give back error
        unauthLogout(firstAccessToken, error);
        return throwError(error);
      }

      if (error.status === 401) {
        // Try refresh
        return refreshOnUnauth(firstAccessToken).pipe(mergeMap(function (accessToken) {
          return from(apiFn(accessToken).apply(void 0, _toConsumableArray(args))).pipe(catchError(function (error) {
            unauthLogout(accessToken, error);
            return throwError(error);
          }));
        }));
      }
    }

    return throwError(error);
  }

  function callAuthApiObservable(apiFn) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return getAccessToken().pipe(mergeMap(function (firstAccessToken) {
      return from(apiFn(firstAccessToken).apply(void 0, args)).pipe(catchError(function (error) {
        return onObsevableError(error, apiFn, firstAccessToken, args);
      }));
    }));
  }

  function callAuthApiPromise(apiFn) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return getAccessToken().toPromise().then(function (firstAccessToken) {
      return apiFn(firstAccessToken).apply(void 0, args)["catch"](function (error) {
        if (firstAccessToken !== null) {
          if (typeof refreshTokenCall !== 'function') {
            // Refresh can't be called
            unauthLogout(firstAccessToken, error);
            return Promise.reject(error);
          }

          if (error.status === 401) {
            // Try refresh
            return refreshOnUnauth(firstAccessToken).toPromise().then(function (accessToken) {
              return apiFn(accessToken).apply(void 0, args)["catch"](function (error) {
                unauthLogout(accessToken, error);
                return Promise.reject(error);
              });
            });
          }
        } // Unauthorized


        return Promise.reject(error);
      });
    });
  } // GioVa 1312 illegal boy


  var firstBootSub = actionObservable.pipe(filter(function (action) {
    return action.type === BOOTSTRAP_AUTH_END;
  }), take(1)).subscribe(function () {
    refreshRoutine.connect();
  });
  var logoutSub = actionObservable.pipe(filter(function (action) {
    return action.type === LOGOUT;
  })).subscribe(function () {
    refreshingSemaphore = false;
  });
  var refreshSub = refreshRoutine.subscribe(function (action) {
    if (action.type === TOKEN_REFRESHING) {
      refreshingSemaphore = true;
    } else if (action.type === TOKEN_REFRESHED) {
      var payload = action.payload;
      refreshingSemaphore = false;
      tokenRef.current = payload;
      dispatch(action);
      storage.setTokens(payload);
    } else if (action.type === LOGOUT) {
      refreshingSemaphore = false;
      logout();
    }
  });

  function unsubscribe() {
    firstBootSub.unsubscribe();
    logoutSub.unsubscribe();
    refreshSub.unsubscribe();
  }

  return {
    callAuthApiObservable: callAuthApiObservable,
    callAuthApiPromise: callAuthApiPromise,
    unsubscribe: unsubscribe
  };
}

var initialState = {
  // Is auth initialized?
  bootstrappingAuth: false,
  bootstrappedAuth: false,
  // Current logged user
  user: null,
  // Tokens
  accessToken: null,
  refreshToken: null,
  expires: null,
  // Login state
  loginLoading: false,
  loginError: null
};
function initAuthState(initialData) {
  if (initialData) {
    // Only fill user and access token together
    if (initialData.user && initialData.accessToken) {
      var _initialData$refreshT, _initialData$expires;

      return _objectSpread(_objectSpread({}, initialState), {}, {
        bootstrappedAuth: true,
        user: initialData.user,
        accessToken: initialData.accessToken,
        refreshToken: (_initialData$refreshT = initialData.refreshToken) !== null && _initialData$refreshT !== void 0 ? _initialData$refreshT : null,
        expires: (_initialData$expires = initialData.expires) !== null && _initialData$expires !== void 0 ? _initialData$expires : null
      });
    } else {
      return _objectSpread(_objectSpread({}, initialState), {}, {
        bootstrappedAuth: true
      });
    }
  }

  return initialState;
}
function authReducer() {
  var _action$payload$refre;

  var previousState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case LOGIN_LOADING:
      return _objectSpread(_objectSpread({}, previousState), {}, {
        loginLoading: true,
        loginError: null
      });

    case LOGIN_FAILURE:
      return _objectSpread(_objectSpread({}, previousState), {}, {
        loginLoading: false,
        loginError: action.error
      });

    case CLEAR_LOGIN_ERROR:
      {
        if (previousState.loginError === null) {
          return previousState;
        }

        return _objectSpread(_objectSpread({}, previousState), {}, {
          loginError: null
        });
      }

    case LOGIN_SUCCESS:
      return _objectSpread(_objectSpread({}, previousState), {}, {
        loginLoading: false,
        user: action.payload.user,
        accessToken: action.payload.accessToken,
        refreshToken: (_action$payload$refre = action.payload.refreshToken) !== null && _action$payload$refre !== void 0 ? _action$payload$refre : null,
        expires: action.payload.expires // logoutFromPermission: false,

      });

    case BOOTSTRAP_AUTH_START:
      return _objectSpread(_objectSpread({}, previousState), {}, {
        bootstrappingAuth: true
      });

    case BOOTSTRAP_AUTH_END:
      {
        var nextState = _objectSpread(_objectSpread({}, previousState), {}, {
          bootstrappedAuth: true,
          bootstrappingAuth: false
        });

        if (action.payload.authenticated) {
          var _action$payload = action.payload,
              user = _action$payload.user,
              accessToken = _action$payload.accessToken,
              _action$payload$refre2 = _action$payload.refreshToken,
              refreshToken = _action$payload$refre2 === void 0 ? null : _action$payload$refre2,
              _action$payload$expir = _action$payload.expires,
              expires = _action$payload$expir === void 0 ? null : _action$payload$expir;
          return _objectSpread(_objectSpread({}, nextState), {}, {
            user: user,
            accessToken: accessToken,
            refreshToken: refreshToken,
            expires: expires
          });
        }

        return nextState;
      }

    case SET_TOKENS:
      return _objectSpread(_objectSpread({}, previousState), {}, {
        expires: action.payload.expires,
        accessToken: action.payload.accessToken,
        refreshToken: action.payload.refreshToken
      });

    case TOKEN_REFRESHED:
      return _objectSpread(_objectSpread({}, previousState), {}, {
        expires: action.payload.expires,
        accessToken: action.payload.accessToken,
        refreshToken: action.payload.refreshToken
      });

    case UPDATE_USER:
      {
        var userOrUpdater = action.payload;
        return _objectSpread(_objectSpread({}, previousState), {}, {
          // NOTE: Improve types when better solution 2
          // https://github.com/microsoft/TypeScript/issues/37663
          user: typeof userOrUpdater === 'function' ? userOrUpdater(previousState.user) : userOrUpdater
        });
      }

    case PATCH_USER:
      return _objectSpread(_objectSpread({}, previousState), {}, {
        user: _objectSpread(_objectSpread({}, previousState.user), action.payload)
      });

    case LOGOUT:
      return _objectSpread(_objectSpread({}, initialState), {}, {
        // Logout doesn't mean reinitialization
        bootstrappedAuth: previousState.bootstrappedAuth
      });

    default:
      return previousState;
  }
}

// https://github.com/reduxjs/redux/blob/master/src/bindActionCreators.ts
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return dispatch(actionCreator.apply(this, args));
  };
}

function bindActionCreators(actionCreators, dispatch) {
  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

var clearLoginError = function clearLoginError() {
  return {
    type: CLEAR_LOGIN_ERROR
  };
};
var updateUser = function updateUser(userOrUpdater) {
  return {
    type: UPDATE_USER,
    payload: userOrUpdater
  };
};
var patchUser = function patchUser(partialUser) {
  return {
    type: PATCH_USER,
    payload: partialUser
  };
};

var actionCreators = /*#__PURE__*/Object.freeze({
  __proto__: null,
  clearLoginError: clearLoginError,
  updateUser: updateUser,
  patchUser: patchUser
});

// Declare Eazy Auth contexts
var AuthStateContext = /*#__PURE__*/createContext(null);
var AuthUserContext = /*#__PURE__*/createContext(null);
var AuthActionsContext = /*#__PURE__*/createContext(null);
function Auth(_ref) {
  var children = _ref.children,
      render = _ref.render,
      loginCall = _ref.loginCall,
      meCall = _ref.meCall,
      refreshTokenCall = _ref.refreshTokenCall,
      storageBackend = _ref.storageBackend,
      _ref$storageNamespace = _ref.storageNamespace,
      storageNamespace = _ref$storageNamespace === void 0 ? 'auth' : _ref$storageNamespace,
      initialData = _ref.initialData,
      onLogout = _ref.onLogout,
      onAuthenticate = _ref.onAuthenticate;

  // Init React Reducer
  var _useReducer = useReducer(authReducer, initialData, initAuthState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      originalDispatch = _useReducer2[1]; // Handle last onAuthenticate callback


  var autenticateCbRef = useRef(onAuthenticate);
  useEffect(function () {
    autenticateCbRef.current = onAuthenticate;
  }, [onAuthenticate]); // Handle last onLogout callback

  var logoutCbRef = useRef(onLogout);
  useEffect(function () {
    logoutCbRef.current = onLogout;
  }, [onLogout]); // Make storage from config
  // NOTE: Switch againg from useMemo storage is a constant fuck off

  var storage = useConstant(function () {
    return makeStorage(storageBackend, storageNamespace);
  });
  var bootstrappedAuth = state.bootstrappedAuth,
      accessToken = state.accessToken,
      refreshToken = state.refreshToken,
      expires = state.expires,
      loginLoading = state.loginLoading,
      loginError = state.loginError; // TODO: Check better strategy and future trouble \w async react
  // This trick is done because token can change over time Es:. the token was refresh
  // But the callApi function instance can't change because this can cause
  // re-running of other useEffect \w callApi as deps or break other
  // memoization ... plus this approch guarantee doesn't trigger re-render
  // of components thath subscribe only to auth actions context when token changes
  // SIDE NOTE
  // In a more idiomatic way at the ends an access token isn't important
  // for your rendering is only a detail implementation of how your
  // server rember who you are ... So if a token change isn't important for
  // rendering but is important for the (*future*) for side effects

  var tokenRef = useRef(accessToken ? {
    accessToken: accessToken,
    refreshToken: refreshToken,
    expires: expires
  } : null); // Is authenticated when has an access token eazy
  // This line can't look stupid but is very very important

  var authenticated = !!accessToken; // Handle the ref of booting status of eazy auth

  var bootRef = useRef(bootstrappedAuth);

  var _useConstant = useConstant(function () {
    var actionSubject = new Subject();

    var dispatch = function dispatch(action) {
      // Handle user callbacks
      if (action.type === BOOTSTRAP_AUTH_END && action.payload.authenticated) {
        var autenticateCb = autenticateCbRef.current;

        if (autenticateCb) {
          autenticateCb(action.payload.user, action.payload.accessToken, false);
        }
      }

      if (action.type === LOGIN_SUCCESS) {
        var _autenticateCb = autenticateCbRef.current;

        if (_autenticateCb) {
          _autenticateCb(action.payload.user, action.payload.accessToken, true);
        }
      }

      if (action.type === LOGOUT) {
        // Call user callback
        var logoutCb = logoutCbRef.current;

        if (logoutCb) {
          logoutCb(tokenRef.current.accessToken);
        } // Clear token ref


        tokenRef.current = null;
      } // Update React state reducer


      originalDispatch(action); // Next Observable

      actionSubject.next(action); // Remove tokens from storage
      // (after applying the new state cause can be slow)

      if (action.type === LOGOUT) {
        storage.removeTokens();
      }
    };

    return [actionSubject.asObservable(), dispatch];
  }),
      _useConstant2 = _slicedToArray(_useConstant, 2),
      actionObservable = _useConstant2[0],
      dispatch = _useConstant2[1]; // Boot Eazy Auth


  useEffect(function () {
    return bootAuth(meCall, refreshTokenCall, storage, dispatch, tokenRef, bootRef);
  }, [dispatch, meCall, refreshTokenCall, storage]); // ~~ Make Actions ~~~
  // Actions creator should't change between renders

  var boundActionCreators = useConstant(function () {
    return bindActionCreators(actionCreators, dispatch);
  });

  var _useConstant3 = useConstant(function () {
    return makePerformLogin(loginCall, meCall, storage, dispatch, tokenRef);
  }),
      _useConstant4 = _slicedToArray(_useConstant3, 2),
      performLogin = _useConstant4[0],
      unsubscribeFromLogin = _useConstant4[1];

  var login = useCallback(function (loginCredentials) {
    if ( // Is eazy auth boostrapped?
    bootstrappedAuth && // Is ma men alredy logged?
    !authenticated) {
      performLogin(loginCredentials);
    }
  }, [authenticated, bootstrappedAuth, performLogin]);
  var performLogout = useCallback(function () {
    // Trigger log out
    dispatch({
      type: LOGOUT
    });
  }, [dispatch]);
  var logout = useCallback(function () {
    if (tokenRef.current) {
      performLogout();
    }
  }, [performLogout]);
  var setTokens = useCallback(function (tokensBag) {
    tokenRef.current = tokensBag;
    dispatch({
      type: SET_TOKENS,
      payload: tokensBag
    });
    storage.setTokens(tokensBag);
  }, [dispatch, storage]);

  var _useConstant5 = useConstant(function () {
    return makeCallApiRx(refreshTokenCall, dispatch, storage, tokenRef, bootRef, actionObservable);
  }),
      callAuthApiPromise = _useConstant5.callAuthApiPromise,
      callAuthApiObservable = _useConstant5.callAuthApiObservable,
      unsubscribe = _useConstant5.unsubscribe; // Memoized actions


  var actions = useMemo(function () {
    return _objectSpread(_objectSpread({}, boundActionCreators), {}, {
      callAuthApiPromise: callAuthApiPromise,
      callAuthApiObservable: callAuthApiObservable,
      login: login,
      logout: logout,
      setTokens: setTokens
    });
  }, [login, logout, boundActionCreators, callAuthApiPromise, callAuthApiObservable, setTokens]); // Derived state for auth
  // Why this even if the token change user still authenticated

  var authState = useMemo(function () {
    return {
      bootstrappedAuth: bootstrappedAuth,
      authenticated: authenticated,
      loginLoading: loginLoading,
      loginError: loginError
    };
  }, [authenticated, bootstrappedAuth, loginLoading, loginError]);
  var authUser = useMemo(function () {
    return {
      user: state.user,
      token: accessToken
    };
  }, [state.user, accessToken]);
  useEffect(function () {
    return function () {
      // Goodbye Space Cowboy
      unsubscribe();
      unsubscribeFromLogin();
    };
  }, [unsubscribe, unsubscribeFromLogin]);
  return /*#__PURE__*/React.createElement(AuthActionsContext.Provider, {
    value: actions
  }, /*#__PURE__*/React.createElement(AuthStateContext.Provider, {
    value: authState
  }, /*#__PURE__*/React.createElement(AuthUserContext.Provider, {
    value: authUser
  }, typeof render === 'function' ? render(actions, authState, authUser) : children)));
}

function useAuthState() {
  var authState = useContext(AuthStateContext);
  return authState;
}
function useAuthActions() {
  var actions = useContext(AuthActionsContext);
  return actions;
}
function useAuthUser() {
  var user = useContext(AuthUserContext);
  return user;
}
// TODO: On the very end this hook sucks and realted types sucks
// in future we must rewrite it or find a more suitable solution
// here for compatibility reasons
function useLogin() {
  var credentialsConf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['username', 'password'];

  var _useState = useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      credentials = _useState2[0],
      setCredentials = _useState2[1];

  var _useAuthState = useAuthState(),
      loginError = _useAuthState.loginError,
      loginLoading = _useAuthState.loginLoading;

  var _useAuthActions = useAuthActions(),
      login = _useAuthActions.login;

  var loginWithCredentials = useCallback(function () {
    login(credentials);
  }, [login, credentials]);
  var handleSubmit = useCallback(function (e) {
    e.preventDefault();
    loginWithCredentials();
  }, [loginWithCredentials]);
  var valuesProps = useMemo(function () {
    return credentialsConf.reduce(function (out, name) {
      return _objectSpread(_objectSpread({}, out), {}, _defineProperty({}, name, {
        value: credentials[name] === undefined ? '' : credentials[name]
      }));
    }, {});
  }, [credentials, credentialsConf]);
  var onChangesProps = useMemo(function () {
    return credentialsConf.reduce(function (out, name) {
      return _objectSpread(_objectSpread({}, out), {}, _defineProperty({}, name, {
        onChange: function onChange(e) {
          var value = e.target.value;
          setCredentials(function (credentials) {
            return _objectSpread(_objectSpread({}, credentials), {}, _defineProperty({}, name, value));
          });
        }
      }));
    }, {});
  }, [setCredentials, credentialsConf]);
  var credentialsProps = useMemo(function () {
    return Object.keys(valuesProps).reduce(function (r, name) {
      return _objectSpread(_objectSpread({}, r), {}, _defineProperty({}, name, _objectSpread(_objectSpread({}, valuesProps[name]), onChangesProps[name])));
    }, {});
  }, [valuesProps, onChangesProps]);
  return _objectSpread({
    handleSubmit: handleSubmit,
    login: loginWithCredentials,
    loginError: loginError,
    loginLoading: loginLoading
  }, credentialsProps);
}

export { Auth as A, useAuthActions as a, useAuthUser as b, useLogin as c, useAuthState as u };
