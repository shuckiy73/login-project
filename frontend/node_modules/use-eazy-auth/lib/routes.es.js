import '@babel/runtime/helpers/esm/defineProperty';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import '@babel/runtime/helpers/esm/slicedToArray';
import React, { createContext, useContext, useMemo, createElement, useRef, useEffect } from 'react';
import 'rxjs';
import '@babel/runtime/helpers/esm/typeof';
import { u as useAuthState, b as useAuthUser } from './hooks.es.js';
import 'rxjs/operators';
import '@babel/runtime/helpers/esm/toConsumableArray';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { Route, Redirect } from 'react-router-dom';

var AuthRoutesContext = /*#__PURE__*/createContext({});

var RedirectAuthRoute = /*#__PURE__*/React.memo(function (_ref) {
  var children = _ref.children,
      component = _ref.component,
      _render = _ref.render,
      spinner = _ref.spinner,
      spinnerComponent = _ref.spinnerComponent,
      _ref$redirectTo = _ref.redirectTo,
      redirectTo = _ref$redirectTo === void 0 ? '/login' : _ref$redirectTo,
      _ref$rememberReferrer = _ref.rememberReferrer,
      rememberReferrer = _ref$rememberReferrer === void 0 ? true : _ref$rememberReferrer,
      userRedirectTo = _ref.userRedirectTo,
      authenticated = _ref.authenticated,
      bootstrappedAuth = _ref.bootstrappedAuth,
      loginLoading = _ref.loginLoading,
      rest = _objectWithoutProperties(_ref, ["children", "component", "render", "spinner", "spinnerComponent", "redirectTo", "rememberReferrer", "userRedirectTo", "authenticated", "bootstrappedAuth", "loginLoading"]);

  return /*#__PURE__*/React.createElement(Route, _extends({}, rest, {
    render: function render(props) {
      if (!bootstrappedAuth || loginLoading) {
        // Spinner or Spinner Component
        return spinnerComponent ? /*#__PURE__*/createElement(spinnerComponent) : spinner !== null && spinner !== void 0 ? spinner : null;
      } // User authenticated


      if (authenticated) {
        // Redirect a logged user?
        if (userRedirectTo) {
          return /*#__PURE__*/React.createElement(Redirect, {
            to: userRedirectTo
          });
        } // Render as a Route


        return children ? children : component ? /*#__PURE__*/createElement(component, props) : _render ? _render(props) : null;
      } // User not authenticated, redirect to login


      var to = typeof redirectTo === 'string' ? {
        pathname: redirectTo
      } : redirectTo;
      return /*#__PURE__*/React.createElement(Redirect, {
        to: _objectSpread(_objectSpread({}, to), {}, {
          state: _objectSpread(_objectSpread({}, to.state), {}, {
            referrer: // TODO: Handle logoutFromPermission when implemented 403 handling
            // in eazy auth ....
            rememberReferrer //&& !auth.logoutFromPermission
            ? props.location : undefined
          })
        })
      });
    }
  }));
});

/**
 * Wrapper around `<Route />`, render given spinner or null while auth is loading
 * then ensure authenticated user otherwise render a `<Redirect />`.
 *
 */
function AuthRoute(_ref2) {
  var localRedirectTest = _ref2.redirectTest,
      localRedirectTo = _ref2.redirectTo,
      localSpinner = _ref2.spinner,
      localSpinnerComponent = _ref2.spinnerComponent,
      localRememberReferrer = _ref2.rememberReferrer,
      rest = _objectWithoutProperties(_ref2, ["redirectTest", "redirectTo", "spinner", "spinnerComponent", "rememberReferrer"]);

  var routesCtxConfig = useContext(AuthRoutesContext);
  var spinner = localSpinner === undefined ? routesCtxConfig.spinner : localSpinner;
  var spinnerComponent = localSpinnerComponent !== null && localSpinnerComponent !== void 0 ? localSpinnerComponent : routesCtxConfig.spinnerComponent;
  var redirectTo = localRedirectTo !== null && localRedirectTo !== void 0 ? localRedirectTo : routesCtxConfig.authRedirectTo;
  var rememberReferrer = localRememberReferrer !== null && localRememberReferrer !== void 0 ? localRememberReferrer : routesCtxConfig.rememberReferrer;
  var redirectTest = localRedirectTest === undefined ? routesCtxConfig.authRedirectTest : localRedirectTest;

  var _useAuthState = useAuthState(),
      authenticated = _useAuthState.authenticated,
      bootstrappedAuth = _useAuthState.bootstrappedAuth,
      loginLoading = _useAuthState.loginLoading;

  var _useAuthUser = useAuthUser(),
      user = _useAuthUser.user;

  var userRedirectTo = useMemo(function () {
    if (user && typeof redirectTest === 'function') {
      var _userRedirectTo = redirectTest(user);

      if (_userRedirectTo) {
        return _userRedirectTo;
      }
    }

    return null;
  }, [user, redirectTest]); // NOTE: split in two components is only an optimization
  // to avoid re-execute Route render when user changes but
  // the output of redirect test doesnt't change

  return /*#__PURE__*/React.createElement(RedirectAuthRoute, _extends({
    userRedirectTo: userRedirectTo,
    authenticated: authenticated,
    bootstrappedAuth: bootstrappedAuth,
    loginLoading: loginLoading,
    redirectTo: redirectTo,
    spinner: spinner,
    spinnerComponent: spinnerComponent,
    rememberReferrer: rememberReferrer
  }, rest));
}

/**
 * Wrapper around `<Route />`, render given spinner or null while auth is loading
 * then ensure guest (not authenticated) user otherwise render a `<Redirect />`.
 *
 */
function GuestRoute(_ref) {
  var _ref2, _ref3;

  var children = _ref.children,
      component = _ref.component,
      _render = _ref.render,
      localSpinner = _ref.spinner,
      localSpinnerComponent = _ref.spinnerComponent,
      localRedirectTo = _ref.redirectTo,
      localRedirectToReferrer = _ref.redirectToReferrer,
      rest = _objectWithoutProperties(_ref, ["children", "component", "render", "spinner", "spinnerComponent", "redirectTo", "redirectToReferrer"]);

  var routesCtxConfig = useContext(AuthRoutesContext);
  var spinner = localSpinner === undefined ? routesCtxConfig.spinner : localSpinner;
  var spinnerComponent = localSpinnerComponent !== null && localSpinnerComponent !== void 0 ? localSpinnerComponent : routesCtxConfig.spinnerComponent;
  var redirectTo = (_ref2 = localRedirectTo !== null && localRedirectTo !== void 0 ? localRedirectTo : routesCtxConfig.guestRedirectTo) !== null && _ref2 !== void 0 ? _ref2 : '/';
  var redirectToReferrer = (_ref3 = localRedirectToReferrer !== null && localRedirectToReferrer !== void 0 ? localRedirectToReferrer : routesCtxConfig.redirectToReferrer) !== null && _ref3 !== void 0 ? _ref3 : true;

  var _useAuthState = useAuthState(),
      authenticated = _useAuthState.authenticated,
      bootstrappedAuth = _useAuthState.bootstrappedAuth;

  return /*#__PURE__*/React.createElement(Route, _extends({}, rest, {
    render: function render(props) {
      if (authenticated) {
        // Redirect to referrer location
        var _ref4 = props,
            location = _ref4.location;

        if (redirectToReferrer && location.state && location.state.referrer) {
          return /*#__PURE__*/React.createElement(Redirect, {
            to: typeof redirectTo === 'string' ? location.state.referrer : // If redirectTo is an object merged the state
            // of location to redirect....
            _objectSpread(_objectSpread({}, location.state.referrer), {}, {
              state: _objectSpread(_objectSpread({}, redirectTo.state), location.state.referrer.state)
            })
          });
        }

        return /*#__PURE__*/React.createElement(Redirect, {
          to: redirectTo
        });
      }

      if (!bootstrappedAuth) {
        // Spinner as element as component or null
        return spinnerComponent ? /*#__PURE__*/createElement(spinnerComponent) : spinner !== null && spinner !== void 0 ? spinner : null;
      } // Render as a Route


      return children ? children : component ? /*#__PURE__*/createElement(component, props) : _render ? _render(props) : null;
    }
  }));
}

/**
 * Wrapper around `<Route />`, render given spinner or null while auth is loading
 * then render given content for both guest and authenticated user.
 *
 */
function MaybeAuthRoute(_ref) {
  var children = _ref.children,
      component = _ref.component,
      _render = _ref.render,
      localSpinner = _ref.spinner,
      localSpinnerComponent = _ref.spinnerComponent,
      rest = _objectWithoutProperties(_ref, ["children", "component", "render", "spinner", "spinnerComponent"]);

  var routesCtxConfig = useContext(AuthRoutesContext);
  var spinner = localSpinner === undefined ? routesCtxConfig.spinner : localSpinner;
  var spinnerComponent = localSpinnerComponent !== null && localSpinnerComponent !== void 0 ? localSpinnerComponent : routesCtxConfig.spinnerComponent;

  var _useAuthState = useAuthState(),
      bootstrappedAuth = _useAuthState.bootstrappedAuth,
      loginLoading = _useAuthState.loginLoading;

  return /*#__PURE__*/React.createElement(Route, _extends({}, rest, {
    render: function render(props) {
      if (!bootstrappedAuth || loginLoading) {
        // Spinner as element as component or null
        return spinnerComponent ? /*#__PURE__*/createElement(spinnerComponent) : spinner !== null && spinner !== void 0 ? spinner : null;
      } // Render as a Route


      return children ? children : component ? /*#__PURE__*/createElement(component, props) : _render ? _render(props) : null;
    }
  }));
}

function shallowEqualObjects(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (!objA || !objB) {
    return false;
  }

  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;

  if (bKeys.length !== len) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    var key = aKeys[i];

    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }

  return true;
}

function useShallowMemo(next) {
  var previousRef = useRef(next);
  var previous = previousRef.current;
  var isEqual = shallowEqualObjects(previous, next);
  useEffect(function () {
    if (!isEqual) {
      previousRef.current = next;
    }
  });
  return isEqual ? previous : next;
}

function AuthRoutesProvider(_ref) {
  var children = _ref.children,
      props = _objectWithoutProperties(_ref, ["children"]);

  var ctxValue = useShallowMemo(props);
  return /*#__PURE__*/React.createElement(AuthRoutesContext.Provider, {
    value: ctxValue
  }, children);
}

export { AuthRoute, AuthRoutesProvider, GuestRoute, MaybeAuthRoute };
